#summary Overview of the planned 2.0 release

= Changes since 1.0 =

==Exceptions==
In Guice 1.0, when a custom provider throws an unchecked exception, sometimes Guice wraps the exception and sometimes it doesn't. It depends on whether the provider is being called directly (via Provider.get()) or indirectly (such as for injecting into another type).

In Guice 2.0, any time a custom provider throws, Guice wraps it in a ProvisionException. This rule is simpler, and it makes it easier to write fault-tolerant code with Guice. 

==Abstract Types==
Guice doesn't support injecting into abstract types. The messaging around this has been improved since 1.0, and some code that was silently failing now throws exceptions.

==Inner Classes==
Guice used to support constructor injection of nonstatic inner classes. So this used to work, but it won't anymore:
{{{
public class FooTest extends TestCase {
  public void testFoo() {
    Foo foo = Guice.createInjector().getInstance(FakeFoo.class)
  }

  class FakeFoo implements Foo {
    @Inject TestFoo() {...}
  }
}
}}}

==Annotation Implementations==
Guice 2.0 fixes the treatment of equals() and hashCode() for fieldless annotations. Annotation implementations that don't implement equals() and hashCode() may have worked in 1.0 but will be broken in 2.0.

==SPI Changes==
SourceProviders have been replaced with `Binder.withSource` and `Binder.skipSources`. These new methods are easier to call and test. They don't require static initialization or static dependencies.

