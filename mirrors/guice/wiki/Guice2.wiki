#summary Overview of the planned 2.0 release

=Overview=

Our plan is to release Guice 2.0 during the summer of 2008.

=New Features=

==Provider Methods==

==Binding Overrides==
[http://publicobject.com/2008/05/overriding-bindings-in-guice.html Override] the bindings from one module with another:
{{{
Module functionalTestModule 
        = Modules.override(new ProductionModule()).with(new OverridesModule());
}}}

==Multibindings, !MapBindings==
Bind elements of [http://publicobject.com/2008/05/guice-multibindings-extension-checked.html Sets] and [http://publicobject.com/2008/05/mapbinder-checked-in.html Maps], then inject the full collection. Bindings are aggregated from all modules.
{{{
public class SnacksModule extends AbstractModule {
  protected void configure() {
    MapBinder<String, Snack> mapBinder
        = MapBinder.newMapBinder(binder(), String.class, Snack.class);
    mapBinder.addBinding("twix").toInstance(new Twix());
    mapBinder.addBinding("snickers").toProvider(SnickersProvider.class);
    mapBinder.addBinding("skittles").to(Skittles.class);
  }
}
}}}

==Introspection API==
Like `java.lang.reflect`, but for Guice. It lets you rewrite a Module, tweaking bindings programatically. It also lets you inspect a created injector, and examine its bindings. This is intended to enable simpler, more powerful extensions and tools for Guice.

==OSGi-friendly AOP==
Guice does bytecode generation internally to implement AOP. In version 2.0, generated classes are loaded by a bridge classloader that works in managed environments such as OSGi.

==Servlets==
Servlets can be injected via `InjectedHttpServlet` and `GuiceServletContextListener`.

==Pluggable Type Converters==
Constant String bindings can be converted to arbitrary types (such as dates, URLs, or colours) using pluggable type converters.

==Small Features==
  * `Binder.getProvider` and `AbstractModule.requireBinding` allow modules to declare and use dependencies.
  * `Binder.requestInjection` allows modules to register instances for injection at Injector-creation time.
  * `Providers.of()` always provides the same instance, useful for testing.
  * `Scopes.NO_SCOPE` allows you make no-scoping explicit.
  * `Matcher.inSubpackage` matches all classes in any child package of the given one.
  * `Types` utility class for creating implementations of generic types.

=Changes since 1.0=

==Exceptions==
In Guice 1.0, when a custom provider throws an unchecked exception, sometimes Guice wraps the exception and sometimes it doesn't. It depends on whether the provider is being called directly (via Provider.get()) or indirectly (such as for injecting into another type).

In Guice 2.0, any time a custom provider throws, Guice wraps it in a !ProvisionException. [http://publicobject.com/2008/04/future-guice-providers-that-throw.html This rule is simpler], and it makes it easier to write fault-tolerant code with Guice. 

!ProvisionException and !OutOfScopeException are now public.

==Abstract Types==
Guice doesn't support injecting into abstract types. The messaging around this has been improved since 1.0, and some code that was silently failing now throws exceptions.

==Inner Classes==
Guice used to support constructor injection of nonstatic inner classes. So this used to work, but it won't anymore:
{{{
public class FooTest extends TestCase {
  public void testFoo() {
    Foo foo = Guice.createInjector().getInstance(FakeFoo.class)
  }

  class FakeFoo implements Foo {
    @Inject TestFoo() {...}
  }
}
}}}

==Keys==
Guice now [http://publicobject.com/2008/06/integerclass-and-intclass-as-guice-keys.html canonicalizes] primitive types (like `int.class`) and array types (like `Integer[].class`) when they're used in Keys. It now supports wildcards like `List<?>` in keys - use `@Provides` to bind these.

==Annotation Implementations==
Guice 2.0 fixes the treatment of equals() and hashCode() for fieldless annotations. Annotation implementations that don't implement equals() and hashCode() may have worked in 1.0 but will be broken in 2.0.

==Injector.getBinding==
Guice 2.0 throws an exception if the binding cannot be resolved. The old version used to return null. To get the old behaviour, use `injector.getBindings().get(key)`.

==SPI Changes==
!SourceProviders have been replaced with `Binder.withSource` and `Binder.skipSources`. These new methods are easier to call and test. They don't require static initialization or static dependencies.