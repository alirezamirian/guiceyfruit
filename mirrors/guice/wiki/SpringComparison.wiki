#summary How does Guice compare to Spring et al?
#labels Featured

  _Preface:_ We don't believe Guice and Spring directly compete, but judging from the questions we've received, comparison's are inevitable. While Spring is a full blown platform, Guice focuses on dependency injection. The following comparison assumes readers have some familiarity with [http://docs.google.com/Doc?id=dd2fhx4z_5df5hw8 Guice concepts].

The Spring Framework, created by Rod Johnson, blazed the Java dependency injection trail. If not the first dependency injection framework, you can certainly credit Spring with pioneering much of what we know about dependency injection and bringing it into the mainstream. Guice might not exist (at least not this early) if not for Spring's example.

Guice is anything but a rehash of Spring. Guice was born purely out of use cases from one of Google's biggest (in every way) applications. We sat down and asked ourselves, how do we really want to build this application going forward? Guice enables our answer. 

Guice wholly embraces annotations and generics, thereby enabling you to wire together and test objects with measurably less effort. Guice proves you can use annotations instead of error-prone, refactoring-adverse string identifiers. 

Some new users fear that the number of annotations will get out of hand. Fear not. You won't have nearly as many different annotations in a Guice application as you have string identifiers in a Spring application.
  # You only need to use annotations when a binding type alone isn't sufficient.
  # You can reuse the same annotation type across multiple bindings (`@Transactional` for example). 
  # Annotations can have attributes with values. You can bind each set of values separately to the same type if you like.

Spring supports two polar configuration styles: explicit configuration and auto-wiring. Explicit configuration is verbose but maintainable. Auto-wiring is concise but slow and not well suited to non-trivial applications. If you have 100s of developers and 100s of thousands of lines of code, auto-wiring isn't an option. Guice uses annotations to support a best-of-both-worlds approach which is concise but explicit (and maintainable).

Some critics have tried to find an analog to Spring's XML (or new Java-based configuration) in Guice. Most times, there isn't any, but sometimes you can't use annotations, and you need to manually wire up an object (a 3rd party component for example). When this comes up, you write a custom provider. A custom provider adds one level of indirection to your configuration and is roughly 1:1 with Spring's XML in complexity. The remaining majority of the time, you'll write significantly less code. 

Eric Burke recently [http://stuffthathappens.com/blog/2007/03/09/guicy-good/ ported a Spring application to Guice]:

  At the end of the day, I compared my (Guice) modules — written in Java — to my 
  Spring XML files. The modules are significantly smaller and easier to read.

  Then I realized about 3/4 of the code in my modules was unnecessary, 
  so I stripped it out. They were reduced to just a few lines of code each.

Oftentimes, it doesn't make sense to port perfectly working code which you won't be changing any time soon to Guice, so Guice works with Spring when possible. You can [http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/spring/SpringIntegration.html bind your existing Spring beans]. Guice supports AOP Alliance method interceptors which means you can use Spring's popular transaction interceptor.

From our experience, most AOP frameworks are too powerful for most uses and don't carry their own conceptual weight. Guice builds method interception in at the core instead of as an afterthought. This hides the mechanics of AOP from the user and lowers the learning curve. Using one object instead of a separate proxy reduces memory waste and more importantly the chances of invoking a method without interceptors. Under the covers, Guice uses a separate handler for each method minimizing performance overhead.

Finally, Guice's unique builder-style design enables unprecedented performance, some 100X faster than Spring for dependency injection (according to [http://google-guice.googlecode.com/svn/trunk/test/com/google/inject/PerformanceComparison.java this benchmark]).

















