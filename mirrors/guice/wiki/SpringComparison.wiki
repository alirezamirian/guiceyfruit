#summary How does Guice compare to Spring?

The Spring Framework, created by Rod Johnson, blazed the Java dependency injection trail. If not the first dependency injection framework, you can certainly credit Spring with pioneering much of what we know about dependency injection and bringing it into the mainstream. Guice might not exist (at least not this early) if not for Spring's example.

You'll find Guice looks very little like Spring. Guice wholeheartedly embraces the new language features introduced in Java 5 and makes dependency injection feel more native to Java, dependency injection "the Java way" you might say. Guice actually manages to give you _more_ upfront type checking than conventional approaches such as factories and service locators. Guice supports generic types; you can bind to `List<User>` and `List<Order>` independently. Guice also has no notion of "Java beans" as the Java 5 language features make them obsolete for our purposes. Where frameworks like Spring make heavy use of string identifiers, we take full advantage of annotations. We enable users to use strings if they like, but we don't encourage it. From our experience, you should never have to resort to string identifiers when using Guice.

Spring forces you to choose between two polar configuration approaches: explicit configuration which is verbose but maintainable, and auto-wiring which is concise but not well suited to non-trivial applications. Guice uses annotations to support a best-of-both-worlds approach which is both concise and maintainable.

Guice works with Spring when possible. By the nature of dependency injection you can easily reuse the same components between the two frameworks. Both Spring and Guice also support the AOP Alliance API which means you can do things like use Spring's transaction interceptor with Guice.

While Spring seems to have everything you could possibly ever need, Guice focuses on dependency injection and follows a use case-driven approach and ignores feature counts. Guice highly prioritizes backward compatibility, but we also don't want to introduce a feature which could limit future innovation or add unnecessary complexity, so all new features undergo a great deal of scrutiny. If you want to take advantage of Spring's higher level frameworks for data access, remoting, etc., you should be able to do so whilst using Guice as your core container.

While Spring externalizes binding information to an XML configuration, Guice chooses to express this information in Java code and externalize only as much configuration as is necessary. Guice uses an EDSL (embedded domain-specific language) design which is a fancy way of saying the Guice configuration looks like a little language implemented using Java. EDSL-based approaches have been popular with such frameworks as EasyMock. 

Finally, Guice's unique design enables unprecedented performance, some 100X faster than Spring for dependency injection. Guice builds method interception in at the core instead of as an afterthought. This hides the mechanics of AOP from the user reducing the chances of "gotchas" and leveling the learning curve, and minimizes performance overhead. 