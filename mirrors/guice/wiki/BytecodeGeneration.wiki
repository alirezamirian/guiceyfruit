#summary Motivation and consequences of generates classes in Guice

Guice performs code generation and class loading. We use this stuff for faster reflection, method interceptors, and to proxy circular dependencies. 

When loading classes, we need to be careful of:
  * *Memory leaks.* Generated classes need to be garbage collected in long-lived applications. Once an injector and any instances it created can be garbage collected, the corresponding generated classes should be collectable.
  * *Visibility.* Containers like `OSGi` use class loader boundaries to enforce modularity at runtime.

For each generated class, there's multiple class loaders involved:
  * *The related class's class loader.* Every generated class services exactly one user-supplied class. This class loader must be used to access members with private and package visibility.
  * *Guice's class loader.*
  * *Our bridge class loader.* This is a child of the user's class loader. It selectively delegates to either the user's class loader (for user classes) or the Guice class loader (for internal classes that are used by the generated classes). This class loader that owns the classes generated by Guice.

The bridge class loader is used unless:
  * A package-private method needs to be intercepted
  * A method in a package-private class needs to be intercepted

Only classes loaded by the bridge class loader will work in an OSGi environment.