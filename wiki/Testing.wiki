#labels Featured
GuiceyFruit supports Guicey Testing by allowing you to inject your dependencies using Guice along with support for JSR 250, Spring, EJB3 or [JNDI] if you require.

You perform injections using the usual *@Inject* annotation from Guice or using JSR 250 annotations like *@PostConstruct*, *@PreDestroy* and *@Resource*.

You can associate the Guice Module(s) to be used by your test case using the following rules

 * annotate your test class with the @Configuration annotation which takes the Module class as a parameter
 * if no annotation is specified then guiceyfruit will look for an inner class called Configuration implementing Module
 * specify the *org.guiceyfruit.modules* system property a space separated list of modules which is useful for reusing a test case with a different module

So you can either use the class naming convention, or use an annotation to denote which module to use. The advantage of the annotation is that you can reuse a single module class with multiple test cases.

For example using an explicit annotation

{{{
// lets specify an exact module
@Configuration(MyModule.class)
pubilc class MyTest extends GuiceyFruitTestCase {
  @Inject
  Cheese cheese;

  public void testSomething() {...}
}
}}}

or using the naming convention

{{{
// lets use the inner class
pubilc class MyTest extends GuiceyFruitTestCase {
  @Inject
  Cheese cheese;

  public void testSomething() {...}

  static class Configuration extends AbstractModule {
   // Guice module goes here ...
  }
}
}}}


== JUnit3 ==

To support JUnit3 you just derive from GuiceyTest case as shown in the examples above or this example below which shows JSR 250 injection.

{{{
@Configuration(Jsr250Module.class)
pubilc class MyTest extends GuiceyFruitTestCase {

  @Resource
  Cheese cheese;

  public void testSomething() {...}
}
}}}

== JUnit4 ==

For JUnit4 support you just need to add the @RunWith annotation as shown

{{{
@RunWith(GuiceyJUnit4.class)
@Configuration(EdamModule.class)
public class AnnotationTest {
    @Inject
    Cheese cheese;

    @Test
    public void testSomething() {...}
}}}

=== Overloading the Guice Module from Maven ===

If you configure your pom.xml so that system properties can be passed in from the command line such as 

{{{
      <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <configuration>
          <systemProperties>
             <property>
              <name>org.guiceyfruit.modules</name>
              <value>${org.guiceyfruit.modules}</value>
            </property>
          </systemProperties>
        </configuration>
      </plugin>
}}}

Then when running tests you can overload the Guice module you want to use for injecting into your test case as follows.

{{{
cd guiceyfruit-junit3
mvn test -Dtest=NamingConventionTest -Dorg.guiceyfruit.modules=org.guiceyfruit.testing.junit3.example.EdamModule
}}}

This should make the test fail (as a different Cheese is injected). You can check that the test works by using the default module by running

{{{
mvn test -Dtest=NamingConventionTest -Dorg.guiceyfruit.modules=
}}}